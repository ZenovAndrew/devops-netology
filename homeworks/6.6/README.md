# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя


```
$currentOp или db.currentOp() - определим текущий ID операции
db.killOp()  - завершает операцию в соотвествии с ID из db.currentOp() 
```
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
```
Судя по информации из интернета, для решения проблемы с долгими запросами требудется правильно выстроить индексы
С помощью метрики pathsNotIndexed можно увидеть индексы которые мог использовать запрос  
Команда $explain используется для отображения метрик использования запросов и индексов.
```


## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?
```
Судя по документации Redis latency troobleshooting, а также из-за особенности работы БД с оперативной памятью,  данная проблема может возникнуть из-за недостатка оперативной памяти

```
 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?
```
Ошибка "Lost connection to MySQL server during query" может быть вызвана 3 причинами:
- проблемой подключения к сети. В данном случае необходимо решить сетевые проблемы. 
- к БД поступает очень много запросов, и БД не успевает их обрабатывать и отвечать. В данном случае надо увеличить  net_read_timeout с 30 секунд по умолчанию до 60 секунд или более, достаточного для завершения передачи данных.
- клиент пытается установить соединение с сервером, но не успевает за отведенной время. В данном случае необходимо увеличить значение connect_timeout 

```

Какие пути решения данной проблемы вы можете предложить?

```
Таким образом, пути решения могут быть:
1. Увеличить значение параметров : net_read_timeout, connect_timeout
2. Перестроить индексы на более оптимальные
3. увеличить мощность системы
```



## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?
```
Это происходить из-за недостатка оперативной памяти.  Out-Of-Memory Killer убирает процесс жрущий оперативную память, чтобы предотвратить падение операционной системы.
Когда заканчивается оперативная память вызывается функция out_of_memory()
В ней есть функция select_bad_process(), которая получает оценку от функции badness(). Под раздачу попадет самый «плохой» процесс. Функция badness() выбирает процесс по определенным правилам.

1. Ядру нужен какой-то минимум памяти для себя.
2. Нужно освободить много памяти.
3. Не нужно завершать процессы, которые используют мало памяти.
4. Нужно завершить минимум процессов.
5. Сложные алгоритмы, которые повышают шансы на завершение для тех процессов, которые пользователь сам хочет завершить.


 
```

Как бы вы решили данную проблему?
```

1. Можно отключить oom-killer (не рекомендуется)
sudo -s sysctl -w vm.oom-kill = 0 # результат команды сохранится до первой перезугрузки
2. Linux может зарезервировать для процессов больше памяти, чем есть, но не выделять ее по факту, и этим поведением управляет параметр ядра Linux. 
За это отвечает переменная vm.overcommit_memory.

0: ядро само решает, стоит ли резервировать слишком много памяти. Это значение по умолчанию в большинстве версий Linux.
1: ядро всегда будет резервировать лишнюю память. Это рискованно, ведь память может закончиться, потому что, скорее всего, однажды процессы затребуют положенное.
2: ядро не будет резервировать больше памяти, чем указано в параметре overcommit_ratio.


В параметре overcommit_ratio указывается процент памяти, для которого допустимо избыточное резервирование.
Если для него нет места, память не выделяется, в резервировании будет отказано. Это самый безопасный вариант, рекомендованный для PostgreSQL. 
На OOM-Killer влияет еще один элемент — возможность подкачки, которой управляет переменная cat /proc/sys/vm/swappiness. 
Эти значения указывают ядру, как обрабатывать подкачку страниц. Чем больше значение, тем меньше вероятности, что OOM завершит процесс, но из-за операций ввода-вывода это негативно сказывается на базе данных. 
И наоборот — чем меньше значение, тем выше вероятность вмешательства OOM-Killer, но и производительность базы данных тоже выше. Значение по умолчанию 60, но если вся база данных помещается в память, лучше установить значение 1.



```

---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
